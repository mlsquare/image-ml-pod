import base64
import os
from io import BytesIO

from fastapi import FastAPI, File, HTTPException, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse, RedirectResponse
from kedro_boot.app.booter import boot_package
from kedro_boot.framework.compiler.specs import CompilationSpec
from matplotlib.figure import Figure
from PIL import Image
from pydantic import BaseModel

from image_ml_pod.pipelines.inf_data_preprocessing.nodes import OutOfDistributionError

# Default project directory, configurable through environment variables
project_dir = os.environ.get("PROJECT_DIR", ".")

# Boot the Kedro session with specified configurations and pipeline setup
session = boot_package(
    package_name="image_ml_pod",
    compilation_specs=[
        CompilationSpec(
            inputs=["inference_sample"],  # Input name expected by the pipeline
            outputs=["predictions", "integrated_gradients"],  # Outputs generated by the pipeline
        )
    ],
    kedro_args={
        "pipeline": "inference",  # Pipeline to run
        "conf_source": os.path.join(project_dir, "conf"),  # Path to configuration files
    },
)

# Initialize FastAPI application
app = FastAPI(title="Image ML Pod")

# Allow all origins for CORS (can be restricted for production use)
origins = ["*"]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,  # Allowed origins
    allow_credentials=True,
    allow_methods=["*"],  # Allowed HTTP methods
    allow_headers=["*"],  # Allowed headers
)

# Define response model for prediction endpoint
class PredictionResponse(BaseModel):
    predictions: list[int]  # List of predictions
    integrated_gradients: list[str]  # List of Base64-encoded gradient visualizations

def serialize_figure(fig: Figure) -> str:
    """
    Convert a Matplotlib figure to a Base64-encoded PNG string.

    Args:
        fig: Matplotlib figure to serialize.
    Returns:
        Base64-encoded string of the figure.
    """
    buf = BytesIO()
    fig.savefig(buf, format="png")  # Save figure to buffer in PNG format
    buf.seek(0)  # Rewind buffer to the beginning
    return base64.b64encode(buf.read()).decode("utf-8")  # Encode as Base64 string

@app.post("/predict")
async def predict(image: UploadFile = File(...)) -> PredictionResponse:
    """
    Endpoint for image-based prediction.
    Args:
        image: Uploaded image file.
    Returns:
        JSON response with predictions and integrated gradients.
    Raises:
        HTTPException: For invalid input or errors during processing.
    """
    try:
        # Read and parse the uploaded image
        image_content = await image.read()
        pil_image = Image.open(BytesIO(image_content))
    except Exception:
        # Raise 400 Bad Request for invalid image uploads
        raise HTTPException(
            status_code=400,
            detail="Invalid Image",
            headers={"X-Error": "InvalidImage"},
        )

    try:
        # Run the inference pipeline with the uploaded image
        results = session.run(inputs={"inference_sample": pil_image})
    except OutOfDistributionError as e:
        # Raise 400 Bad Request for OOD detection errors
        raise HTTPException(
            status_code=400,
            detail=f"Out of distribution error: {str(e)}",
            headers={"X-Error": "OutOfDistributionError"},
        )
    except Exception as e:
        # Handle unexpected errors with a 500 Internal Server Error
        raise HTTPException(
            status_code=500,
            detail=f"Internal Server Error: {str(e)}",
            headers={"X-Error": "InternalServerError"},
        )

    # Serialize integrated gradients as Base64 strings
    gradients_base64 = [
        serialize_figure(fig) for fig in results["integrated_gradients"]
    ]

    predictions = results["predictions"]  # Extract predictions from pipeline output

    # Prepare response payload
    response = {
        "predictions": predictions,
        "integrated_gradients": gradients_base64,
    }

    return JSONResponse(content=response)

@app.get("/")
async def docs_redirect():
    """
    Redirect to API documentation at /docs.
    """
    return RedirectResponse(url="/docs")
